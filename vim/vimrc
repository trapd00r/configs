" ${VIMRUNTIME}/vimrc
"       owner  Magnus Woldrich <m@japh.se>
"       btime  2009-04-24
"       mtime  2022-04-24
"         git  http://github.com/trapd00r/configs/
"         irc  japh@irc.libera.chat #vim #zsh #perl
" ‗‗‗‗‗‗‗‗‗‗‗‗ ‗‗‗‗‗‗‗‗‗‗‗‗‗ ‗‗‗‗ ‗‗‗‗ ‗‗‗‗

" plugin/blockwise.vim
" plugin/smartcom.vim


" ========== INIT START =================================
filetype plugin indent on
syntax on

runtime macros/matchit.vim                                                 " % on if/else
"runtime syntax/hitest.vim                                                  " dump all hi groups in a buffer
set all&                                                                   " turn everything off, in case of evil vendor vimrcs
let &runtimepath  = $VIMRUNTIME                                            " $XDG_CONFIG_HOME/vim
set helpfile=$XDG_CONFIG_HOME/vim/doc/help.txt                             " hlep
set exrc                                                                   " enables the reading of vimrc in ./
set path+='$HOME/dev/air8/cgi-bin/core/lib/'                               " for gf etc
set path+='$HOME/dev/air8'

" useful in various places later
let g:hostname = hostname()

call plug#begin(expand($VIMRUNTIME) . '/plugged')

" This way, I'm loading the dev versions of my plugins if it looks like
" I'm about to work on them.

" LS_COLORS.vim      - dircolors syntax
" LS_COLORS-edir.vim - dircolors syntax for an edir session
" automkdir.vim      - vim ~/dev/doesntexist/butthatisfine.vim
" cccp.vim           - colorcolumn at cursor position
" currentline.vim    - highlight the current line like a marker pen
" eqalignsimple.vim  - alignment magic with = and +
" foldsearches.vim   - fold around searches
" hlnext.vim'        - highlight current search result
" neverland          - my colorscheme
" udpopup.vim        - custom popup menus
" vim-syntax-notes   - only useful for me
" yankmatches.vim    - yank/delete matches from a previous search operation

for myplugin in [
\  'automkdir.vim',
\  'cccp.vim',
\  'currentline.vim',
\  'eqalignsimple.vim',
\  'foldsearches.vim',
\  'hlnext.vim',
\  'neverland-vim-theme',
\  'udpopup.vim',
\  'vim-scriptease',
\  'vim-syntax-notes',
\  'yankmatches.vim',
\  'LS_COLORS-edir.vim',
\  'LS_COLORS.vim',
\ ]

  let path = expand("%:p:h:h")

  " developing, use dev version of plugin
  " ~/dev/LS_COLORS.vim/
  if path =~ '\vdev[/]' . myplugin
    Plug path

  " use stable version
  else
    Plug 'trapd00r/' . myplugin
  endif
endfor



" extra syntax rules
Plug 'trapd00r/vim-after-syntax-vim',  { 'for': 'vim' }
Plug 'trapd00r/vim-after-syntax-perl', { 'for': 'perl' }
Plug 'trapd00r/vim-after-syntax-zsh',  { 'for': ['zsh', 'sh'] }

Plug 'DanielFGray/DistractionFree.vim'  " toggle various things in one keystroke
Plug 'DanilaMihailov/vim-tips-wiki'     " tips from vim tips wiki inside :help
Plug 'airblade/vim-gitgutter'           " git diff markers, git hunks
Plug 'airblade/vim-matchquote'          " % for quotes, backticks and pipes
Plug 'airblade/vim-rooter'              " change to project root, good for symlinks
Plug 'aymericbeaumet/vim-symlink'       " let vim auto-follow symlinks, so that vim ~/.vimrc used absolute path
Plug 'hotchpotch/perldoc-vim'           " press K for perldoc
Plug 'junegunn/fzf'                     " fuzzy...
Plug 'junegunn/fzf.vim'                 " ... all the things
Plug 'junegunn/rainbow_parentheses.vim' " better rainbows
Plug 'junegunn/vim-peekaboo'            " peek at registers prior to pasting
Plug 'junegunn/vim-plug'                " self
Plug 'junegunn/goyo.vim'                " distractionless
Plug 'kien/ctrlp.vim'                   " I don't use this but the one below depends on it
Plug 'kshenoy/vim-signature'            " place, toggle, display marks
Plug 'lfv89/vim-interestingwords'       " adds ability to highlight specific words
Plug 'machakann/vim-highlightedundo'    " highlight undo operations
Plug 'machakann/vim-highlightedyank'    " highlight regular yank operations
Plug 'markonm/traces.vim'               " live preview of ex commands
Plug 'rhysd/clever-f.vim'               " keep smashing f
Plug 'rhysd/committia.vim'              " better experience dealing with commit msg
Plug 'smkent/vim-pipe-preview'          " scrollbind preview;  pip3 install mdv3
Plug 'tacahiroy/ctrlp-funky'            " function navigator
Plug 'tpope/vim-fugitive'               " git wrapper
Plug 'tpope/vim-repeat'                 " repeat all the things
Plug 'tpope/vim-surround'               " surround all the things
Plug 'vim-scripts/AnsiEsc.vim'          " highlight strings with esc seq in its color
Plug 'vimwiki/vimwiki'                  " wiki waka wiki waka
Plug 'w0rp/ale'                         " linting
Plug 'wookayin/fzf-ripgrep.vim'         " grep -> fuzzyfind results
Plug 'zirrostig/vim-schlepp'            " move visual selections around
Plug 'johngrib/vim-game-code-break'     " arkanoid in my vim

call plug#end()
" ========== INIT END ===================================
" ========== OPTIONS START ==============================
let &termencoding = &encoding                                              " should be utf-8; exceptions below
set autoindent                                                             " copy indent from previous line
set autoread                                                               " read file again if changed outside of vim
set backspace=start,indent,eol                                             " what backspace, ^w etc will operate on
set cindent                                                                " c program indenting
set clipboard=unnamed                                                      " define clipboard registers to use
set cmdheight=2                                                            " avoid 'Press ENTER to continue' prompts
set colorcolumn&                                                           " useful at times but disabled by default
set complete=.,w,b,u,d,k,kspell                                            " insert mode completion for ^n, ^p
set complete+=k~/dev/askas/utils-askas/vim/installed_perl_modules.txt      " complete all perl package names
set completeopt+=menuone                                                   " use popup menu for completion even if only one match
set cursorline                                                             " only use this for CursorLineNr
set define=[^A-Za-z_]                                                      " for macro definition
set diffopt=filler,iwhite,context:2,vertical                               " settings for vimdiff
set display+=lastline,uhex                                                 " changes the way text is displayed
set expandtab                                                              " use spaces instead of tabs
set fileencodings=utf-8,latin1                                             " list of fileencodings to try
set fillchars+=fold:\                                                      " chars used for filling the folded line when folded
set foldcolumn=2                                                           " width of foldcolumn
"set foldclose=all                                                          " autoclose fold when jumping out of it
set foldenable                                                             " when off, all folds are open
set foldignore=#                                                           " lines starting with char will get their fold level from surrounding lines
set foldlevel=99                                                           " folds with a higher level will be closed
set foldlevelstart=99                                                      " do not fold by default
set foldmarker={,}                                                         " and these can be adjusted anywhere of course
set foldmethod=marker                                                      " fold on defined markers
set foldminlines=2                                                         " close folds with n lines minimum
set foldnestmax=4                                                          " maximum nesting when using syntax or indent foldmethods
set foldopen=block,hor,jump,mark,percent,quickfix,search,tag,undo          " actions that will open a fold
set formatoptions=qro                                                      " options for formatting; like gq
set formatprg=perl\ -MText::Autoformat\ -e'autoformat({right=>80})'        " much better formatting
set grepprg=internal                                                       " what grep to use
set helpheight=5                                                           " height of help window
set helplang=en                                                            " language of help
set hidden                                                                 " better buffer handling
set history=50                                                             " ex command history, q:
set hlsearch                                                               " highlight searches
set ignorecase                                                             " ignore case, but also uses smartmatch
set include=\\<\\(use\\\|require\\)\\>                                     " perl module to...
set includeexpr=substitute(substitute(v:fname,'::','/','g'),'$','.pm','')  " ... perl module in filesystem
set incsearch                                                              " show matches while typing
set isfname+=:                                                             " add : to filename pattern
set iskeyword+=$                                                           " perl scalar
set iskeyword+=%                                                           " perl hash
set iskeyword+=@-@                                                         " perl array
set iskeyword+=:                                                           " perl colon
set iskeyword-=,                                                           " remove , from keyword
set laststatus=2                                                           " always how statusline
set lazyredraw                                                             " do not redraw screen while executing macros etc
set list                                                                   " visualize non-visual characters
set listchars&                                                             "  '- set it to empty first
set listchars+=conceal:⌦                                                   "  '- what to show when concealing something
set listchars+=eol:\                                                       "  '- end of line
set listchars+=extends:\                                                   "  '- last column when wrap is off
set listchars+=nbsp:                                                       "  '- non-breaking space
set listchars+=precedes:\                                                  "  '- first column when wrap is off
set listchars+=tab:»\                                                      "  '- tab
set listchars+=trail:·                                                     "  '- trailing whitespace
set magic                                                                  " set magic on for regex but I use \v anyway
set matchpairs+=<:>,«:»,｢:｣                                                " match more things with %
"set matchpairs+==:;                                                        " match : with %
set matchtime=20                                                           " time to show the match with %
set maxfuncdepth=1000                                                      " avoid recursive functions
set maxmapdepth=500                                                        " avoid recursive mappings
set maxmemtot=200000                                                       " max memory for all buffers together
set modeline                                                               " yes I want to use modelines
set modelines=2                                                            " number of lines to check for a modeline
set nobackup                                                               " no backups, I have persistent undo
set noequalalways                                                          " do not auto-equalize size of windows
set noerrorbells                                                           " bells are for double-o 7
set nomore                                                                 " disable the more-prompt
set noshowmode                                                             " disable mode change messages
set nospell spelllang=en_us                                                " no spell on, but set spelllang so I can use it if I want to
set nostartofline                                                          " modifies some movement commands
set noswapfile                                                             " no swaps please
set nowrap                                                                 " no wrapping since it changes the appearance of the data
set nowritebackup                                                          " no backups please
set nrformats=alpha,hex                                                    " defines what a number is for increasing/decreasing with ^a,^x
set number norelativenumber                                                " show line numbers
set numberwidth=2                                                          " width of number column
set preserveindent                                                         " preserve indent when using <<, >> etc
set pumheight=10                                                           " height and number of suggestions to show in completion popup
set report=0                                                               " always show how many lines have been modified
set ruler                                                                  " show line and column number
set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%)                         " format for the above
set scrolloff=40                                                           " context above and below cursor; 999 = exactly in the middle
set shiftwidth=2                                                           " number of spaces to use for a tab
set shortmess=aIoOT                                                        " avoid as many hit-enter prompts as possible
set showbreak=↳                                                            " start of lines when wrap is on
set showcmd                                                                " show (partial) cmd in last line of screen
set showmatch                                                              " briefly display match when jumping to a bracket
set showtabline=0                                                          " hide tablines, don't use
set signcolumn=number                                                      " use numbers column for signs, too
set smartcase                                                              " case ignored unless uppercase used anywhere
set smarttab                                                               " insert blanks according to shiftwidth, tabstop, expandtab
set splitbelow                                                             " preferably split below
set ssop=buffers,folds,globals,help,localoptions,options,resize            " session options for mksession
set synmaxcol=300                                                          " maximum column to highlight
set t_Co=256                                                               " terminal supports 256 colors
set tabpagemax=4                                                           " max tab pages when using -p flag
set tabstop=2                                                              " shouldn't modify this the help states..?
set tags=./tags,tags,~/dev/tags,~/dev/askas/utils-askas/vim/tags           " location of tag files
set term=rxvt-unicode-256color                                             " set terminal
set textwidth=80                                                           " maximum width of text
set timeout                                                                " time out on mappings
set timeoutlen=3000                                                        " how long to wait prior to timeout
set title                                                                  " send a title string to the terminal
set ttimeoutlen=50                                                         " the same for terminal keycodes
set ttyfast                                                                " my terminal is very fast
set undodir=~/var/vim/undo                                                 " where to keep the undos
set undofile                                                               " undo file for all the undos
set undolevels=1024                                                        " persisent undo for 1024 actions
set updatetime=200                                                         " for CursorHold events and GitGutter signs
set viminfo=h,'100,\"100,:20,n~/var/vim/viminfo                            " what to save in the viminfo
set virtualedit=block                                                      " virtualedit for visual block mode
set visualbell t_vb=                                                       " disable visual bells
set wildchar=<Tab>                                                         " completion char in cmdline
set wildignore=*.swp,*.bak,*~,blib,*.o,*.png,*.jpe?g,.git,.svn,*.so,.hg    " completion should ignore
set wildmenu                                                               " command-line completion, enhanced mode
set wildmode=list:longest,full                                             " completion mode

" ========== OPTIONS END ================================

color neverland

" ========== MAPPINGS START =============================
" ATTENTION! <leader> #1
let mapleader=','

" toggle listchars
map <C-q> :set list!<cr>

" go to tag definition and go back
nnoremap <backspace> <C-]>
nnoremap <tab>       <C-T>

" perldoc what's under the cursor
nnoremap <C-k> :Perldoc<cr>

" search only inside a block/scope/function
nnoremap <leader>/ :normal vi{<esc><esc>/\%V

" jump to the next mark
nnoremap <leader>m :normal ]`<cr>

" dont move when using *
nnoremap <silent> * :let s=winsaveview()<cr>*:call winrestview(s)<cr>

" alt+<dot> - rg *, fzf results
nnoremap <Esc>. :RgFzf*<cr>

" evaluate and execute lines of viml
" needs https://github.com/trapd00r/vim-scriptease
nnoremap <silent> E :Execute<cr>
vnoremap <silent> E :Execute<cr>

" highlight the current line
" https://github.com/trapd00r/currentline.vim
nnoremap <silent> <leader><return> :call HighlightCurrentLine('♥')<cr>

" toggle colorcolumn at cursor position
" unless cursor position is 1, then disable it
nnoremap <silent> <leader>cc :call CCCP()<cr>

" change surrounding quotes
nnoremap <leader>' :normal cs"'<cr>
nnoremap <leader>" :normal cs'"<cr>

" go to start of function
nnoremap <silent> <leader>q :normal [m<cr>
" go to end of function
"nnoremap <silent> <leader>a :normal ]m<cr>

" change the ugly q^single quoted^ to something better
" you want to do
"   setxkbmap se -variant nodeadkeys for the ^
nmap <leader>^ cs^<bar>

" highlight undo/redo operations
nmap u     <Plug>(highlightedundo-undo)
nmap <C-r> <Plug>(highlightedundo-redo)

" highlight the word under the cursor in differently
" these things are cleared with me <C-l> mapping
nnoremap <silent> <leader>h1 :execute 'match CurrentWord1 /\<<c-r><c-w>\>/'<cr>
nnoremap <silent> <leader>h2 :execute 'match CurrentWord2 /\<<c-r><c-w>\>/'<cr>
nnoremap <silent> <leader>h3 :execute 'match CurrentWord3 /\<<c-r><c-w>\>/'<cr>
nnoremap <silent> <leader>h4 :execute 'match CurrentWord4 /\<<c-r><c-w>\>/'<cr>
nnoremap <silent> <leader>h5 :execute 'match CurrentWord5 /\<<c-r><c-w>\>/'<cr>

" toggle comments
"nmap # <Plug>CommentorLine
"vmap # <Plug>Commentor

" close all folds
nnoremap <leader>fc zM

" undoentire git hunk
nnoremap <leader>u :GitGutterUndoHunk<cr>

" go to next git changed hunk
nnoremap <leader>n :GitGutterNextHunk<cr>

" distractionfree
nnoremap <C-t> <Esc>:DistractionsToggle<cr>

" delete block
nnoremap db da{

" folding around git changed hunks, showing 3 lines of context
nmap <silent>         zg  :GitGutterFold <bar> normal zr<cr>

" folding around searches
nmap <silent> <expr>  zz  FS_ToggleFoldAroundSearch({'context':1})
nmap <silent> <expr>  z2  FS_ToggleFoldAroundSearch({'context':2})

" folding around use statements
nmap <silent> <expr>  zu  FS_FoldAroundTarget('^\s*use\s\+\S.*;',{'context':1})

" folding around warns
nmap <silent> <expr>  zw  FS_FoldAroundTarget('^\s*warn\s\+\S.*;',{'context':1})

" folding around mappings
nmap <silent> <expr>  zm  FS_FoldAroundTarget('^[nvxo]\(nore\)\?map',{'context':1})

" show the current function name
map <C-s> :call ShowFuncName()<cr>

" use quickfix list to go to func definition
nnoremap <C-o> :CtrlPFunky<cr>

" a double <cr> to supress "Press enter to continue"
"nnoremap <C-c> :exe '!markdown_previewer %'<cr><cr>
nnoremap <silent> <C-c> :<C-U>PipePreview<CR>

" next buffer
nnoremap <C-n>     :bnext<cr>

nnoremap <leader>b :Buffers<cr>

" replace standard :ls with fzf-powered one.
cabbrev ls <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'Buffers' : 'ls')<cr>

" Moving around
nnoremap J  10j
nnoremap K  10k

vnoremap J  10j
vnoremap K  10k

" highlight custom text objects
"nnoremap <silent><expr> <backspace> hl#mark()
"nnoremap <silent><expr> <tab> hl#unmark('line')
"vnoremap <silent><expr> <tab> hl#unmark('block')
"highlight HL cterm=bolditalic ctermbg=fg ctermfg=bg

" Return to the previous cursor position
" --------------------------------------
"   '' returns to the previous line
"   `` returns to the previous line and position
" --------------------------------------
" I never want #1 so I make it a nop and map #2 to #1

map '' <nop>
map '' ``

" Move visual blocks around or dupe them
vmap <unique> <C-h> <Plug>SchleppLeft
vmap <unique> <C-j> <Plug>SchleppDown
vmap <unique> <C-k> <Plug>SchleppUp
vmap <unique> <C-l> <Plug>SchleppRight
vmap <unique> <C-d> <Plug>SchleppDup

"let g:Schlepp#dupTrimWS = 1

" resize windows like in sdorfehs
nnoremap <C-W>J :exe 'resize ' . winheight(0) / 2<cr>
nnoremap <C-W>K :exe 'resize ' . winheight(0) * 2<cr>

" my redraw key does a few things:
"   - remove hlsearch
"   - remove hlnext,
"   - clear highlighted yanks
"   - clear highlighted lines
"   - clear highlighted CurrentWord*
"   - clear highlighted InterestingWords
"   - reset colorcolumn
"   - redraw screen
nnoremap <silent> <C-l>
  \ :call HLNextOff()                   <BAR>
  \ :nohl                               <BAR>
  \ :hi clear YankedMatches             <BAR>
  \ :call HighlightCurrentLine('clear') <BAR>
  \ :set colorcolumn&                   <BAR>
  \ :redraw <CR>

" resize windows like in sdorfehs
nnoremap <C-W>J :exe 'resize ' . winheight(0) / 2<cr>
nnoremap <C-W>K :exe 'resize ' . winheight(0) * 2<cr>

" sort and operate on visual block selections
" press enter or add flags to sort, i.e -n
" this will sort _only_ what's selected and not the entire
" lines as is default vim behaviour
"vnoremap S :Blockwise !sort<space>
vnoremap B :Blockwise<cr>
vnoremap S :SortByBlock<cr>

" toggle folds with Enter
nnoremap <silent> <C-m> @=(foldlevel('.')?'za':"\<Space>")<cr>

" search for word under cursor
"nnoremap  <silent> <C-g> :exe ":silent! Rg <C-R><C-W>"<cr>
"

" better movement in ex mode
cnoremap  <C-*> <c-a>
cnoremap  <C-_> <c-f>
cnoremap  <C-a> <home>
cnoremap  <C-b> <left>
cnoremap  <C-d> <del>
cnoremap  <C-e> <end>
cnoremap  <C-f> <right>
cnoremap  <C-h> <S-Left>
cnoremap  <C-j> <down>
cnoremap  <C-k> <up>
cnoremap  <C-l> <S-Right>
cnoremap  <C-n> <down>
cnoremap  <C-p> <up>
cnoremap  <M-b> <S-Left>
cnoremap  <M-f> <S-Right>

" ATTENTION! <LEADER> KEY NUMBER TWO
let mapleader=';'

" and back to <leader> #1
let mapleader=','


" ========== FZF START ==================================
" git status
nnoremap <leader>gs :GFiles?<cr>

" use :Gfiles for ctrlp if in a git repo
" otherwise, use normal fzf
map <expr> <C-p> fugitive#head() != '' ? ':GFiles --cached --others --exclude-standard<CR>' : ':Files<CR>'

" commits for the current buffer, vselect a line to track changes for it
nnoremap <leader>gc :BCommits<cr>
vnoremap <leader>gc :BCommits<cr>

" display commit history for the current line
nnoremap ? V:BCommits<cr>

" commits for the entire project
nnoremap <leader>Gc :Commits<cr>

" most recent files
nnoremap <space> :History<cr>

" commandline history
nnoremap <leader>H :History:<cr>

" search history, `
command! QHist call fzf#vim#search_history({'right': '40'})
nnoremap <leader>s :QHist<cr>

" lines, in entire project
nnoremap <leader>l :Lines<cr>

" buffer lines
nnoremap <leader>L :BLines<cr>

" all the marks
nnoremap <leader>M :Marks<cr>

" all the mappings
"nnoremap <leader>m :Maps<cr>

" quickly change ft
nnoremap <leader>ft :Filetypes<cr>

"command! -bang AIR8files call fzf#vim#files('~/dev/askas/air8', <bang>0)
"nnoremap <leader>air :AIR8files<cr>

"nnoremap <leader>f :RgFzf

" Rg word under cursor, and filter results with fzf
nnoremap <C-g> :RgFzf*<cr>

" go to function def
nnoremap <C-S-G> :RgDefFzf*<cr>

" ========== FZF END ====================================
" ========== MAPPINGS END ===============================
" ========== FUNCTIONS START ============================

" Add code block start/end tags to vimwiki (or markdown)
" The range keyword makes sure we run this function over the
" entire range, instead of over each line in the range
"
" The filetype argument is optional with perl as a default
"   :call VimwikiAddCodeBlock('sql') inserts sql code blocks instead
function! VimwikiAddCodeBlock(filetype = 'perl') range
  " add google prettify syntax hl matter two lines above
"  call append(line("'<") - 1, '<pre class="prettyprint">')

  " if needed, we can specify the language to use like this:
  " call append(line("'<") - 1, '<pre class="prettyprint lang-' .. a:filetype .. '>')

  " Append start of code block and filetype
  " before the visual selection
  call append(line("'<") - 1, '{{{' .. a:filetype)

  " Append end of code block and matter after the visual selection
"  call append(line("'>") + 0, '</pre>')
  call append(line("'>") + 0, '}}}')

  " Expand visual selection by one line
  execute ':' . line("'<") - 1

  " set mark
  normal m<
endfunction

" redirect command to a new scratch buffer
function! Redir(cmd) abort
    let output = execute(a:cmd)
    20new
    setlocal nobuflisted buftype=nofile bufhidden=wipe noswapfile
    call setline(1, split(output, "\n"))
endfunction
command! -nargs=1 Redir silent call Redir(<f-args>)

" scratch window for temp things
" bound in my window manager like this:
" bind Return exec urxvt -fg white -bg black -sbg +sb -e vim -c 'call Scratch()'
function! Scratch()
  noswapfile hide enew
  setlocal buftype=nofile
  setlocal bufhidden=hide
  setlocal ft=perl
  file scratch
  startinsert
endfunction

" try to figure out the filetype when there's no extension
function! s:infer_filetype()
  let firstline = getline(1)

  " perl5
  if firstline  =~# '^#!.*perl'
    set filetype=perl
    return

  " shell script
  elseif firstline =~# '\v^#!/bin/(ba|z)?sh'
    set filetype=zsh
    return
  endif
endfunction

" show syntax group for item under cursor
nmap <C-e> :call SynStack()<CR>
fu! SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfu

" context in statusbar; function, scope or block
function! ContextInStatusbar()
  let lnum = line(".")
  let col = col(".")
  echohl ModeMsg
  let g:current_function = getline(search("^[^ \t#/]\\{2}.*[^:]\s*$", 'bWn'))
  echohl None

  "" matches and returns a str only if the lines matches any of the following:
  "  viml: fu!, function!, function!
  "    js: function
  "  perl: sub
  "     c: grab_key(KeySym keysym, unsigned int modifiers, Window grab_window)
  "   css: .store_more_info_wrapper .store_name (a little broken..)
  " shell: pastebin() {
  " shell: if/elif:
"  if g:current_function =~ '\v(^fu[!]?n?[!]?|^sub|^\S+[(].+[)])|^.+[{]|(el)?if \[\[?'
  if g:current_function =~ '\v(^fu[!]?n?[!]?|^sub|^\S+[(].+[)])|^.+[{]|(el)?if \[\[?'
    " remove sub or function keyword
    let funcname = substitute(g:current_function, '\v(sub|fu[!]?n?(ction)?[!]?)\s*', '', '')
    return funcname

    " can also include scopes or blocks
    " return g:current_function
  endif
  return ''
endfun

" show function name
function! ShowFuncName()
  let lnum = line(".")
  let col = col(".")
  echohl ModeMsg
  echo getline(search("^[^ \t#/]\\{2}.*[^:]\s*$", 'bW'))
  echohl None
  call search("\\%" . lnum . "l" . "\\%" . col . "c")
endfun

" vidir - sanitize filenames (based on x)
fu! Vidir_Sanitize(content)
  mark z

  "silent! %s/\(\_^[ ]*\)\@<![ ]\+/_/g
  "%s/\(\_^\s*\|\_^\s\+\d\+\)\@<!\s/_/g

  silent! %s/\v[åä]/a/g
  silent! %s/\v[ö]/o/g
  silent! %s/\v[ÅÄ]/A/g
  silent! %s/\v[Ö]/O/g
  silent! %s/,/./g
  execute "silent! %s/\v[;<>*|'&!#)([\]{}]//g"
  silent! %s/\v_+\ze[.]|\zs[.]\ze_+//g
  silent! %s/[$]/S/g
  silent! %s/\v-{2,}/-/g
  silent! %s/\v_-_/-/g
  silent! %s/\v[_]{2,}/_/g
  silent! %s/\v[/_-]@<\=[a-z]/\U&/g
  silent! %s/\v_(Feat|The|It|Of|At)_/\L&/ig
  silent! %s/\v_(Och|N[åa]n)_/\L&/g

  if (a:content == 'music') || (a:content == 'mvid')
    "silent! %s/\v./\L&/g
    silent! %s/\v^\s*[0-9]+\s+\zs\s+/_/g
    silent! %s/\(\_^[ ]*\)\@<![ ]\+/_/g
    :silent! %s/\v[&]/feat/g
    :silent! %s/\v(_[el]p[_]?)/\U\1/ig
    :silent! %s/\v([_-]?cd[sm][_-]?|flac|[_-]demo|vinyl|[_-](web|pcb|osv))/\U\1/ig
  elseif (a:content == 'tv')
    :silent! %s/\v^\s*[0-9]+\s+\zs\s+/./g
    silent! %s/\(\_^[ ]*\)\@<![ ]\+/./g
    silent! %s/\v[.]-[.]/./g
  else
    :silent! %s/\v[&]/and/g
  endif

  'z
  delmark z
endfu

" vidir - sort of title-case helper
fu! Vidir_SmartUC()
  :s/\w\@<=\ze\u/_/g
  :s/\v_+/_/g
  ":s/\<\@<![A-Z]/_&/g
endfu

" remove trailing whitespace
fu! RemoveTrailingCrap()
  if search('\s\+$', 'n')
    :%s/\s\+$//
  endif
  if search( nr2char(182) . '$' )
    :execute ":%s/" . nr2char(182) . "//"
  endif
endfu
" ========== FUNCTIONS END ==============================
" ========== AUTOCOMMANDS START =========================
" whenever something's yanked, write it to a file
"au TextYankPost * :call YankedToYankLog()
"
"function! YankedToYankLog()
"  let yanked = getreg('*')
"
"  " do not want only whitespace
"  if yanked !~ '\S'
"    return
"  endif
"
"  let yanklog = expand('~/yanklog')
"
"  " append yanked data to log
"  call writefile(split(yanked, "\n", 1), yanklog, 'a')
"endfunction

" disable automatic comment on newline
autocmd Filetype * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

" enable use of $LS_COLORS coloring in appropriate files
autocmd BufRead,BufNewFile *gitignore,fd.ignorefile,MANIFEST setf LS_COLORS

" set custom options for man/perldoc (C-k etc)
" the perldoc filetype is my own custom modified perl.vim
autocmd FileType man set nonumber | set filetype=perldoc

" enable Rainbows everywhere
autocmd BufRead,BufNewFile * :RainbowParentheses<cr>

" set quickfix window height and make it modifiable
autocmd BufWinEnter quickfix setlocal winheight=40 | setlocal modifiable

" fold config files in a nice way
autocmd BufRead ~/.vimrc,~/etc/vim/vimrc set foldlevel=0 | let &foldmarker='START =====,END ====='
autocmd BufRead ~/.zshrc,~/etc/zsh/zshrc set foldlevel=0 | let &foldmarker='START =====,END ====='

" try to figure out the filetype when there's no extension
" often the case in my bin (~/dev/utils/) directory
autocmd BufRead  * call s:infer_filetype()

" evaluate the comment char for the current buffer
" now, the variable b:comment will always hold the correct
" char used for comments in that specific filetype
" this is used for ToggleComment() among other things, mapped
" to #
autocmd BufRead,BufNewFile * silent let b:comment=split(&commentstring, '%s')[0]


" return to last edit position when opening files
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif

" show only sub defns (and maybe comments)...
let perl_sub_pat = '^\s*\%(sub\|func\|method\|package\)\s\+\k\+'
let vim_sub_pat  = '^\s*fu\%[nction!]\s\+\k\+'
augroup FoldSub
    autocmd!
    autocmd BufEnter * nmap <silent> <expr>  zp  FS_FoldAroundTarget(perl_sub_pat,'context':1)
    autocmd BufEnter * nmap <silent> <expr>  za  FS_FoldAroundTarget(perl_sub_pat.'\zs\\|^\s*#.*','context':0, 'folds':'invisible')
    autocmd BufEnter *.vim,.vimrc nmap <silent> <expr>  zp  FS_FoldAroundTarget(vim_sub_pat,'context':1)
    autocmd BufEnter *.vim,.vimrc nmap <silent> <expr>  za  FS_FoldAroundTarget(vim_sub_pat.'\\|^\s*".*','context':0, 'folds':'invisible')
    autocmd BufEnter * nmap <silent> <expr>             zv  FS_FoldAroundTarget(vim_sub_pat.'\\|^\s*".*','context':0, 'folds':'invisible')
augroup END


" escape faster!
augroup FastEscape
  autocmd!
  set notimeout
  set ttimeout
  set timeoutlen=10
  autocmd InsertEnter * set timeout
  autocmd InsertLeave * set notimeout
augroup END

" sadly there is no tt2 + html + js syntax file that works
autocmd BufRead,BufNewFile *.tt setf javascript

autocmd BufNewFile,BufRead  MANIFEST              set filetype=LS_COLORS
autocmd BufNewFile,BufRead  vidir*                set filetype=LS_COLORS
autocmd BufNewFile,BufRead  Changes               set filetype=changelog

autocmd BufRead,BufNewFile *.*htm*,*.xml          setl sw=1
autocmd BufNewFile         *.txt                  setl cc=

autocmd BufRead            /etc/fstab,~/etc/fstab highlight fsDeviceError ctermfg=fg ctermbg=bg cterm=italic

" update modification time
autocmd BufWrite ~/.irssi/scripts/*.pl %s/changed     => ["'].*/\="changed     => '" . strftime("%c") . "',"/e
autocmd BufWrite ~/.irssi/*            %s/changed     => ["'].*/\="changed     => '" . strftime("%c") . "',"/e
" ========== AUTOCOMMANDS END ===========================
" ========== COMMANDS START =============================

" replace a few builtin commands with versions that send the
" results elsewhere
cabbrev scriptnames <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'Scriptnames' : 'scriptnames')<cr>
cabbrev messages    <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'Messages'    : 'messages')<cr>
cabbrev verbose     <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'Verbose'     : 'verbose')<cr>

" you'll need my vim fork: http://github.com/trapd00r/wim
if v:progname == 'wim'
  comclear
  try
    " this one is especially annoying
    command! tohtml  TOhtml
    command! vresize vert resize 80
    command! hresize resize 60
    command! Write   write
    command! Command command
  catch /^Vim\%((\a\+)\)\=:E183/
  endtry
endif
" ========== COMMANDS END ===============================
" ========== STATUSLINE START ===========================
highlight StatusLine   ctermfg=233 ctermbg=234 cterm=none
highlight StatusLineNC ctermfg=233 ctermbg=234 cterm=none

"highlight link User1 ModeMsg
highlight User1 ctermfg=111 ctermbg=234 cterm=bolditalic
highlight User2 ctermfg=106 ctermbg=234 cterm=none
highlight User3 ctermfg=250 ctermbg=234 cterm=none
" User4 is set to the calculated LS_COLORS for the current file below
highlight User4 ctermfg=032 ctermbg=234 cterm=none
highlight User5 ctermfg=245 ctermbg=234 cterm=none
highlight User6 ctermfg=220 ctermbg=234 cterm=none
highlight User7 ctermfg=240 ctermbg=234 cterm=none
highlight User8 ctermfg=160 ctermbg=234 cterm=none
highlight User9 ctermfg=197 ctermbg=234 cterm=none

" Now, these regexes are obviously bad, but this function will only be used for
" this only purpose so it doesn't matter.
" Here's an aid for generating this:
" curl -s https://raw.githubusercontent.com/trapd00r/LS_COLORS/master/LS_COLORS | grep -Pv '^(?:[#*]|TERM)|^$' | perl -pe 's{^\.?(\S+)\s+(?:[34]8;5;(\d+))}{elsif(a:filename =~ "\v.+\.$1")\n  highlight User4 ctermfg=$2 ctermbg=234 cterm=none};s{;\d+$}{}' | perl -pe "s/\"/'/g"

function! LsColorForStatusLine(filename)
  if(a:filename =~ '\v.+\.sh')
    highlight User4 ctermfg=172 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.vim')
    highlight User4 ctermfg=106 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.txt')
    highlight User4 ctermfg=188 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.(css|sass)')
    highlight User4 ctermfg=125 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.csv')
    highlight User4 ctermfg=078 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.js[mp]?')
    highlight User4 ctermfg=074 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.json')
    highlight User4 ctermfg=178 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.log')
    highlight User4 ctermfg=190 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.(markdown|md)')
    highlight User4 ctermfg=190 ctermbg=234 cterm=bold

  elseif(a:filename =~ '\vREADME|CHANGES')
    highlight User4 ctermfg=190 ctermbg=234 cterm=bold

  elseif(a:filename =~ '\v.+\.php')
    highlight User4 ctermfg=081 ctermbg=234 cterm=none

  elseif(a:filename =~ '\vMakefile([.]PL)?')
    highlight User4 ctermfg=196 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.pl')
    highlight User4 ctermfg=208 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.pm')
    highlight User4 ctermfg=203 ctermbg=234 cterm=none


  elseif(a:filename =~ '\v.+\.(sql|sqlite)')
    highlight User4 ctermfg=222 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.t$')
    highlight User4 ctermfg=114 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.tt$')
    highlight User4 ctermfg=173 ctermbg=234 cterm=none

  elseif(a:filename =~ '\v.+\.html?$')
    highlight User4 ctermfg=132 ctermbg=234 cterm=none

  else
    highlight User4 ctermfg=137 ctermbg=234 cterm=none
  endif
endfun

function! SetStatusLineAskasButik()
  return expand("$ASKAS_BUTIK")
endfun

" do it like so I can color a/m/r differently
function! GitStatusStatusLine(opt)
  let [added,modified,removed] = GitGutterGetHunkSummary()

  if [added,modified,removed] == [0, 0, 0]
    return ""
  endif

  if a:opt == 'added' && added != 0
    return ' ' . added . ' '
  elseif a:opt == 'modified' && modified != 0
    return ' ' . modified . ' '
  elseif a:opt == 'removed' && removed != 0
    return ' ' . removed . ''
  else
    return ''
  endif
endfunction

function! GitBranchStatusLine()
  let current_branch = fugitive#head()
  let shorter = substitute(current_branch, 'Magnus/', '', '')
  return printf("%.25s", shorter)
endfunction

" display either:
"   scp1/.vimrc
"   Code/Module.pm
function! FileNameStatusLine()
  let one_dir_up = expand('%:p:h:t')
  let basename   = expand('%:t')

  if one_dir_up != '.'
    return one_dir_up .. '/' .. basename
  else
    return basename
  endif
endfunction

autocmd BufRead,BufNewFile,BufEnter * call LsColorForStatusLine(expand('%:p'))
set statusline=
"set statusline +=%1*\ %n\ %*                          " buffer number
set statusline +=\ %5*%{&ff}%*\                        " file format
set statusline +=%3*%y%*\                              " file type
set statusline +=\%7*¦%9*\                             " askås butik
set statusline +=%{SetStatusLineAskasButik()}          " askås butik
set statusline +=\ \%7*¦%4*\ %{FileNameStatusLine()}   " basename of file
set statusline +=%2*%m%*                               " modified flag
set statusline +=\%7*\ ¦                               " delimiter
set statusline +=%2*%{GitStatusStatusLine('added')}    " # added lines
set statusline +=%9*%{GitStatusStatusLine('modified')} " # modified lines
set statusline +=%8*%{GitStatusStatusLine('removed')}  " # removed lines
set statusline +=\%7*\ ¦                               " delimiter
set statusline +=\ %6*%{GitBranchStatusLine()}%5*      " shortened git branch
set statusline +=\%7*\ ¦\ \%1*%{ContextInStatusbar()}  " current function or block
"set statusline +=%1*%=%5l%*                            " current line
"set statusline +=%1*/%L%*                              " total lines
"set statusline +=%1*%4v\ %*                            " virtual column number
"set statusline +=%1*0x%04B\ %*                         " character under cursor
" ========== STATUSLINE END =============================
" ========== PLUGIN OPTIONS START =======================

" Show only function name and the current block in the context window
hi link ContextBorder FoldColumn
let g:context_border_char = '═'
let g:context_highlight_border = 'ContextBorder'
let g:context_highlight_tag = '<hide>'
let g:context_max_height = 2

"do not like 3-window split
let g:committia_use_singlecolumn = 'always'
" perl linting
let g:ale_perl_perl_options = '-c -Mwarnings -Ilib -It/lib'
let g:ale_perl_perlcritic_showrules = 1
let g:ale_type_map = {
\    'perlcritic': {'ES': 'WS', 'E': 'W'},
\}

" highlight interesting words
let g:interestingWordsTermColors = ['196', 'white', '109', '137', '186', '222']
let g:interestingWordsRandomiseColors = 0

" preview markdown directly in vim
let g:pipe_preview_command = 'mdv -'

" let me map myself
let g:conflict_marker_enable_mappings = 0

" how long a yank operations will be highlighted, in ms
let g:highlightedyank_highlight_duration = 1000

" to allow for highlighting of Conceal myself
let g:indentLine_setColors = 0

" different char for different indent level
let g:indentLine_char_list = ['|', '¦', '┆', '┊']

" defaults to &clipboard setting if not specified here
let g:YankMatches#ClipboardRegister = '*'

" use git diff colors for signs set with ma
let g:SignatureMarkTextHLDynamic                = 1
let g:gitgutter_override_sign_column_highlight  = 0
let g:gitgutter_max_signs                       = 8500
let g:gitgutter_show_msg_on_hunk_jumping        = 1
let g:extradite_width                           = 40

" list of things to disable when turning distractions off
let g:distraction_free#toggle_options = [
  \ 'cursorline',
  \ 'colorcolumn',
  \ 'cursorcolumn',
  \ 'number',
  \ 'relativenumber',
  \ 'list',
  \ 'ruler',
  \ 'showtabline',
  \ 'laststatus',
  \ 'foldcolumn',
\]

let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }
">


" ========== CTRLP START ================================
"let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[.]git$|test[/]|_VERKTYG|docs[/]',
  \ 'file': '\v\.(exe|so|dll)$',
  \ 'link': 'some_bad_symbolic_links',
  \ }

if executable('rg')
  set grepprg=rg\ --color=never
  let g:ctrlp_user_command = 'rg %s --files --color=never --glob ""'
  let g:ctrlp_use_caching = 0
else
  let g:ctrlp_clear_cache_on_exit = 0
endif

let g:ctrlp_cmd = 'CtrlPMixed'
let g:ctrlp_by_filename = 1

let g:ctrlp_funky_matchtype = 'path'
let g:ctrlp_funky_syntax_highlight = 1

let g:ctrlp_map = ''
" ========== CTRLP END ==================================
" ========== PLUGIN OPTIONS END =========================
" ========== SYNTAX OPTIONS START =======================

let g:c_comment_strings            = 1
let g:c_gnu                        = 1
let g:c_space_errors               = 1
let g:c_syntax_for_h               = 1
let g:dircolors_is_slackware       = 1
let g:highlight_sedtabs            = 1
let g:indent_guides_auto           = 0
let g:lua_subversion               = 0
let g:lua_version                  = 5
let g:mpc_lyrics_use_cache         = 1
let g:netrw_http_cmd               = 'wget'
let g:netrw_http_xcmd              = '-q -O'
let g:perl_compiler_force_warnings = 0
let g:perl_extended_vars           = 1
let g:perl_include_pod             = 1
let g:perl_moose_stuff             = 1
let g:perl_no_scope_in_variables   = 1
let g:perl_no_sync_on_global_var   = 1
let g:perl_no_sync_on_sub          = 1
let g:perl_nofold_packages         = 1
let g:perl_pod_formatting          = 1
let g:perl_pod_spellcheck_headings = 1
let g:perl_string_as_statement     = 1
let g:perl_sync_dist               = 1000
let g:perl_want_scope_in_variables = 1
let g:perlhelp_prog                = '/usr/bin/perldoc'
let g:readline_has_bash            = 1
let g:rg_highlight                 = 1
let g:sh_fold_enabled              = 4
let g:sh_is_posix                  = 1
let g:sh_maxlines                  = 200
let g:sh_minlines                  = 100
let g:space_no_jump                = 1
let g:tex_conceal                  = 1
let g:vim_indent_cont              = 2
let g:vimsyn_embed                 = 'p'
let g:vimsyn_folding               = 'afp'
let g:vt_author                    = 'Magnus Woldrich'
let g:vt_email                     = 'm@japh.se'
let g:vt_template_dir_path         = '~/etc/vim/templates/'
let g:xf86conf_xfree86_versio      = 2
" ========== SYNTAX OPTIONS END =========================
" ========== HIGHLIGHTING START =========================

highlight Normal ctermfg=white ctermbg=bg cterm=italicbold

" highlight the current line
highlight CurrentLine   ctermbg=184 ctermfg=bg cterm=bolditalic

" highlight the matches that have been yanked to a register and
" the system clipboard
highlight YankedMatches ctermfg=bg ctermbg=196 cterm=bolditalic

" highlight regular yanks
if g:hostname == 'tp'
  highlight HighlightedyankRegion ctermfg=bg ctermbg=167 cterm=none
else
  highlight HighlightedyankRegion ctermfg=bg ctermbg=185 cterm=bolditalic
endif

" CurSearch highlighting group added so might be able to remove HLNext
" https://github.com/vim/vim/commit/a43993897aa372159f682df37562f159994dc85c
highlight HLNext                      ctermfg=053  ctermbg=197 cterm=none

" highlight word under the cursor in different ways
highlight CurrentWord1 ctermfg=196 cterm=none
highlight CurrentWord2 ctermfg=196 cterm=bold
highlight CurrentWord3 ctermfg=196 cterm=italic
highlight CurrentWord4 ctermfg=196 cterm=bolditalic
highlight CurrentWord5 ctermfg=196 cterm=bolditalicunderline

" highlight next occurence of fF/tT
highlight CleverFChar   ctermfg=184 cterm=boldunderlineitalic
highlight CleverFCursor ctermbg=fg ctermfg=bg

" highlight undo operations
highlight HighlightedundoChange ctermbg=bg ctermfg=034 cterm=bold

" trackperlvars
highlight default      TRACK_PERL_VAR             ctermfg=none   ctermbg=bg    cterm=underlinebolditalic
highlight default      TRACK_PERL_VAR_QUESTION    ctermfg=white  ctermbg=bg    cterm=bold
highlight default      TRACK_PERL_VAR_LOCKED      ctermfg=none   ctermbg=none  cterm=reverse
highlight default      TRACK_PERL_VAR_UNDECLARED  ctermfg=196    ctermbg=bg    cterm=none
highlight default      TRACK_PERL_VAR_UNUSED      ctermfg=116    ctermbg=bg    cterm=none
highlight default      TRACK_PERL_VAR_BUILTIN     ctermfg=190    ctermbg=bg    cterm=none
highlight default      TRACK_PERL_VAR_ACTIVE      ctermfg=196    ctermbg=bg    cterm=italicbold

highlight link ColorColumn  CursorLine

highlight CursorColumn            ctermfg=fg   ctermbg=234 cterm=none
highlight CursorLine              ctermfg=none ctermbg=234
highlight Error                   ctermfg=089  ctermbg=250 cterm=bolditalicreverse
highlight ErrorMsg                ctermfg=137  ctermbg=bg  cterm=bolditalic
highlight Folded                  ctermfg=238  ctermbg=233 cterm=none
highlight FoldColumn              ctermfg=236  ctermbg=233 cterm=none
highlight IncSearch               ctermfg=053  ctermbg=197  cterm=bolditalic


highlight ModeMsg                                          cterm=bolditalic
highlight Search                  ctermfg=197 ctermbg=053  cterm=none
highlight SpecialKey              ctermfg=239
highlight Statement                                        cterm=italic
highlight VertSplit               ctermfg=234 ctermbg=233  cterm=none
highlight Visual                  ctermfg=197 ctermbg=053  cterm=reverse

highlight clear LineNr
highlight link LineNr FoldColumn

highlight! clear Conceal
highlight link Conceal FoldColumn

highlight qfFileName              ctermfg=208
highlight qfLineNr                ctermfg=033              cterm=italicbold
highlight qfSeparator             ctermfg=232

highlight CtrlPMatch              ctermfg=196              cterm=bold

highlight GitGutterAdd            ctermfg=034
highlight GitGutterChange         ctermfg=198
highlight GitGutterDelete         ctermfg=160


au filetype highlight markdownXmlElement      ctermfg=197
highlight markdownXmlEmptyElement ctermfg=037
highlight markdownJekyllFrontMatter ctermfg=137

" highlight the current line number only
highlight clear CursorLine
highlight link CursorLineNr LineNr
highlight CursorLineNr ctermfg=208


" ========== HIGHLIGHTING END ===========================
" ========== ASKåS START ===============================
set encoding=utf-8
autocmd BufRead,BufNewFile $HOME/dev/askas/air8/* silent setlocal fileencoding=iso-8859-1 | set nolist
"autocmd BufRead,BufNewFile $HOME/dev/askas/air8/* DistractionsToggle
autocmd BufRead,BufNewFile $HOME/dev/askas/* setlocal cc&
autocmd BufRead,BufNewFile $HOME/dev/askas/* setlocal synmaxcol&

let g:fullpath=expand('%:p')
autocmd BufEnter * let fullpath=expand('%:p')
autocmd BufRead,BufNewFile,BufEnter $HOME/dev/askas/* let &makeprg = 'publish_vimmake ' .. g:fullpath
autocmd BufRead,BufNewFile,BufEnter $HOME/dev/askas/air8/* silent setlocal noexpandtab
autocmd BufRead,BufNewFile *.md set ft=markdown nospell

nmap <C-b> :make<cr>
" ========== ASKåS END =================================
" ========== TEMPLATES START ============================
autocmd BufNewFile *.vim silent! 0r $VIMRUNTIME/templates/template.vim
autocmd BufNewFile *.c   silent! 0r $VIMRUNTIME/templates/template.c

autocmd Filetype perl
  \   setl makeprg=perl\ -c\ %\ $*
  \ | setl errorformat=%f:%l:%m
  \ | setl keywordprg=perldoc\ -f

autocmd BufNewFile *.pl
  \   silent! 0r $VIMRUNTIME/templates/template.pl
  \ | setf perl
  \ | call search('APP')
  \ | normal di':startinsert

autocmd BufNewFile *.PL
  \   silent! 0r ~/etc/vim/templates/template.PL
  \ | setf perl
  \ | call search('__PACKAGE__')
  \ | exe 'normal dt} '
  \ | startinsert

autocmd BufNewFile *.pm
  \   silent! 0r $VIMRUNTIME/templates/template.pm
  \ | setf perl
  \ | call cursor(0, 9)
  \ | exe 'normal d$A '
  \ | startinsert

autocmd BufNewFile *.t
  \   silent! 0r $VIMRUNTIME/templates/template.t
  \ | setf perl
  \ | 6
  \ | exe 'normal o'
  \ | startinsert

autocmd BufNewFile *.md,*.markdown
  \   silent! 0r $VIMRUNTIME/templates/template.markdown
  \ | setf markdown
  \ | 0
  \ | exe 'normal d$A'
  \ | startinsert

" template for oneshot quick scripts using entire air stack
autocmd BufNewFile *.air
  \   silent! 0r ~/dev/askas/utils-askas/vim/templates/air_oneshot.air
  \ | 0
  \ | exe 'normal Go'
" ========== TEMPLATES END ==============================
" ========== ABBREVATIONS START =========================

" 2022-04-24 16:36:25
iab xnow <C-R>=strftime("%Y-%m-%d %H:%M:%S")<CR>

" Data::Dumper with options
ia DD use Data::Dumper;<cr><cr>{<cr>package Data::Dumper;<cr>no strict 'vars';<cr>$Terse = $Indent = $Useqq = $Deparse = $Sortkeys = 1;<cr>$Quotekeys = 0;<cr>}<cr>

" input $var
ia wd warn Dumper();<left><left>

" comment block
ia CC ################################################################################<cr>#<cr>###############################################################################<up><backspace>
" ========== ABBREVATIONS END ===========================
" ========== COMPLETION START ===========================
runtime plugin/smartcom.vim

" add extra completions (mainly for Perl programming)...

let ANYTHING = ""
let NOTHING  = ""
let EOL      = '\s*$'

                " Left     Right      Insert                             Reset cursor
                " =====    =====      ===============================    ============
call SmartcomAdd( '<<',    ANYTHING,  "\<BS>\<BS>«"                                    )
call SmartcomAdd( '>>',    ANYTHING,  "\<BS>\<BS>»"                                    )
call SmartcomAdd( '?',     ANYTHING,  '?',                               {'restore':1} )
call SmartcomAdd( '?',     '?',       "\<CR>\<ESC>O\<TAB>"                             )
call SmartcomAdd( '{{',    ANYTHING,  '}}',                              {'restore':1} )
call SmartcomAdd( '{{',    '}}',      NOTHING,                                         )
call SmartcomAdd( 'qr{',   ANYTHING,  '}xms',                            {'restore':1} )
call SmartcomAdd( 'qr{',   '}xms',    "\<CR>\<C-D>\<ESC>O\<C-D>\<TAB>"                 )
call SmartcomAdd( 'm{',    ANYTHING,  '}xms',                            {'restore':1} )
call SmartcomAdd( 'm{',    '}xms',    "\<CR>\<C-D>\<ESC>O\<C-D>\<TAB>",                )
call SmartcomAdd( 's{',    ANYTHING,  '}{}xms',                          {'restore':1} )
call SmartcomAdd( 's{',    '}{}xms',  "\<CR>\<C-D>\<ESC>O\<C-D>\<TAB>",                )
call SmartcomAdd( '\*\*',  ANYTHING,  '**',                              {'restore':1} )
call SmartcomAdd( '\*\*',  '\*\*',    NOTHING,                                         )

" Handle single : correctly...
call SmartcomAdd( '^:\|[^:]:',  EOL,  "\<TAB>" )

" In the middle of a keyword: delete the rest of the keyword before completing...
                " Left     Right                    Insert
                " =====    =====                    =======================
"call SmartcomAdd( '\k',    '\k\+\%(\k\|\n\)\@!',    "\<C-O>cw\<C-X>\<C-N>",           )
"call SmartcomAdd( '\k',    '\k\+\_$',               "\<C-O>cw\<C-X>\<C-N>",           )

" after an alignable, align
function! AlignOnPat (pat)
    return "\<ESC>:call EQAS_Align('nmap',{'pattern':'" . a:pat . "'})\<CR>A"
endfunction

                " Left         Right        Insert
                " ==========   =====        =============================
call SmartcomAdd( '=',         ANYTHING,    "\<ESC>:call EQAS_Align('nmap')\<CR>A")
call SmartcomAdd( '=>',        ANYTHING,    AlignOnPat('=>') )
call SmartcomAdd( '\s#',       ANYTHING,    AlignOnPat('\%(\S\s*\)\@<= #') )
call SmartcomAdd( '[''"]\s*:', ANYTHING,    AlignOnPat(':'),                   {'filetype':'vim'} )
call SmartcomAdd( ':',         ANYTHING,    "\<TAB>",                          {'filetype':'vim'} )


                " Left         Right   Insert                                  Where
                " ==========   =====   =============================           ===================
" perl keywords
call SmartcomAdd( '^\s*for',   EOL,    " my $___ (___) {\n___\n}\n___",        {'filetype':'perl'} )
call SmartcomAdd( '^\s*if',    EOL,    " (___) {\n___\n}\n___",                {'filetype':'perl'} )
call SmartcomAdd( '^\s*while', EOL,    " (___) {\n___\n}\n___",                {'filetype':'perl'} )
call SmartcomAdd( '^\s*given', EOL,    " (___) {\n___\n}\n___",                {'filetype':'perl'} )
call SmartcomAdd( '^\s*when',  EOL,    " (___) {\n___\n}\n___",                {'filetype':'perl'} )
call SmartcomAdd( '^\s*sub',   EOL,    " ___ (___) {\n___\n}\n___",            {'filetype':'perl'} )


" convert between single- and double-quoted string endings
call SmartcomAdd(      '''[^"]*"',  NOTHING,  "\<ESC>?'\<CR>:nohlsearch\<CR>r\"a",        {'restore':1+1} )
call SmartcomAdd( 'q\@<!q{[^"]*"',  NOTHING,  "\<BS>}\<ESC>?q{\<CR>:nohlsearch\<CR>sqq",  {'restore':1+2} )
call SmartcomAdd(     '"[^'']*''',  NOTHING,  "\<ESC>?\"\<CR>:nohlsearch\<CR>r'a",        {'restore':1+1} )
call SmartcomAdd(   'qq{[^'']*''',  NOTHING,  "\<BS>}\<ESC>?qq{\<CR>:nohlsearch\<CR>2sq", {'restore':1+1} )


" when autocompleting within an identifier, prevent duplications
augroup Undouble_Completions
    autocmd!
    autocmd CompleteDone *  call Undouble_Completions()
augroup END

" when completing inside an identifer, it's doubled
" that's bad, fix this
function! Undouble_Completions ()
    let col  = getpos('.')[2]
    let line = getline('.')
    call setline('.', substitute(line, '\(\.\?\k\+\)\%'.col.'c\zs\1', '', ''))
endfunction

" ========== COMPLETION END =============================
" ========== NOTES START ================================
" zz Fold around searches
" zu Fold around use statements
"
" <leader>ym - yank matches
" <leader>yM - yank non matches
"
" <leader>dm - delete matches
" <leader>dM - delete non matches
"
" ^vB - blockwise : operations
"
" ga => char info
"
" <leader><return> - highlight the current line
"
" <leader>cc - toggle colorcolum at cursor positions
" ========== NOTES END ==================================

" ========== TERMCAP START ==============================
" force an update of the statusline
let &ro =&ro

" cursor color in insert mode
let &t_SI = "\e]12;#ff5f00\x7"

" cursor color elsewhere
let &t_EI = "\e]12;#ff005f\x7"

" cursor solid block
let &t_EI .= "\e[2 q"

" here I define my own cterm attributes
" undercurl start
let &t_Cs = "\e[1;3;4m"

" undercurl end
let &t_Ce = "\e[m"

" strikethrough start
let &t_Ts = "\e[4;7m"
" strikethrough end
let &t_Te = "\<Esc>[m"

" underline color
let &t_AU= "\<Esc>[38;5;137m"

" standout start
let &t_so = "\<Esc>[48;5;234m"
" standout end
let &t_se = "\<Esc>[m"

" term raw mode start
let &t_TI = "\<Esc>[>4;2m"
" term raw mode end
let &t_TE = "\<Esc>[>4;m"

" reset cursor when we leave vim
autocmd VimLeave * silent !echo -ne "\033]12;gray\007"
" ========== TERMCAP END ================================
" ========== VIMWIKI START ==============================
let g:vimwiki_list = [{
  \     'path': '~/dev/wiki/japh.wiki/',
\ }]

let g:vimwiki_list = [{'path': '$HOME/dev/wiki/japh.wiki',
  \ 'template_path': '$HOME/dev/wiki/templates',
  \ 'template_default': 'def_template',
  \ 'template_ext': '.html'}]

" add the pre tag for inserting code snippets
let g:vimwiki_valid_html_tags = 'b,i,s,u,sub,sup,kbd,br,hr, pre, script'

" enable syntax highlighting in html output
" let g:vimwiki_listing_hl = 1

" conceal {{{sql
let g:vimwiki_conceal_pre = 1
au BufRead,BufNewFile *.wiki set filetype=vimwiki | map <C-b> :Vimwiki2HTMLBrowse<cr>

highlight VimwikiBold cterm=none ctermfg=172


" ========== VIMWIKI END ================================
